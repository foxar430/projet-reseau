import pygame
import random
import sys
import time
import os
from lo3ba_ai import BattleshipAI


pygame.init()


SCREEN_WIDTH = 1000
SCREEN_HEIGHT = 700
GRID_SIZE = 10
CELL_SIZE = 40
GRID_PADDING = 50
FONT_SIZE = 24


WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (200, 200, 200)
LIGHT_BLUE = (173, 216, 230)
DEEP_BLUE = (0, 80, 125)
BLUE = (0, 120, 215)
RED = (255, 0, 0)
GREEN = (0, 180, 0)
YELLOW = (255, 215, 0)
NAVY = (0, 0, 80)
OCEAN = (65, 105, 225)
LIGHT_GRAY = (220, 220, 220)
ORANGE = (255, 165, 0)  
SOFT_RED = (255, 100, 100)  


MENU = 0
SETUP = 1
GAMEPLAY = 2
GAME_OVER = 3
ONLINE_SETUP = 4
ONLINE_WAITING = 5

class Ship:
    def __init__(self, size, name):
        self.size = size
        self.name = name
        self.hits = 0
        self.coordinates = []
        self.sunk = False
        self.horizontal = True
        self.placed = False
    
    def hit(self):
        self.hits += 1
        if self.hits == self.size:
            self.sunk = True
            return True
        return False

    def draw(self, screen, x, y, cell_size, is_selected=False):
        """Draw ship with enhanced appearance"""
        padding = 2
        width = self.size * cell_size - padding * 2 if self.horizontal else cell_size - padding * 2
        height = cell_size - padding * 2 if self.horizontal else self.size * cell_size - padding * 2
        
        # Create ship rect
        ship_rect = pygame.Rect(x + padding, y + padding, width, height)
        
        # Choose color and border based on selection state and sunk status
        if self.sunk:
            color = SOFT_RED
            border_color = RED
        else:
            color = DEEP_BLUE if not is_selected else YELLOW
            border_color = YELLOW if is_selected else BLUE
        
        # Draw ship body
        pygame.draw.rect(screen, color, ship_rect)
        pygame.draw.rect(screen, border_color, ship_rect, 2, border_radius=3)
        
        # Add details to the ship
        if self.horizontal and self.size > 1:
            # Draw segments for horizontal ship
            for i in range(1, self.size):
                segment_x = x + i * cell_size
                pygame.draw.line(screen, border_color, 
                                (segment_x, y + padding),
                                (segment_x, y + height + padding - 1), 1)
        elif not self.horizontal and self.size > 1:
            # Draw segments for vertical ship
            for i in range(1, self.size):
                segment_y = y + i * cell_size
                pygame.draw.line(screen, border_color, 
                                (x + padding, segment_y),
                                (x + width + padding - 1, segment_y), 1)

class Explosion:
    def __init__(self, x, y, is_hit=True):
        self.x = x
        self.y = y
        self.is_hit = is_hit
        self.frame = 0
        self.max_frames = 8
        self.timer = 0
        self.frame_delay = 40  # milliseconds

    def update(self, dt):
        self.timer += dt
        if self.timer >= self.frame_delay:
            self.frame += 1
            self.timer = 0
        return self.frame < self.max_frames

    def draw(self, screen):
        if self.is_hit:
            # Draw hit explosion (red expanding circle)
            radius = (self.frame + 1) * 5
            alpha = 255 - (self.frame * 30)
            if alpha < 0:
                alpha = 0
                
            # Create a surface with per-pixel alpha
            surf = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
            pygame.draw.circle(surf, (255, 0, 0, alpha), (radius, radius), radius)
            screen.blit(surf, (self.x - radius, self.y - radius))
        else:
            # Draw miss splash (blue expanding circle)
            radius = (self.frame + 1) * 3
            alpha = 200 - (self.frame * 25)
            if alpha < 0:
                alpha = 0
                
            # Create a surface with per-pixel alpha
            surf = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
            pygame.draw.circle(surf, (255, 255, 255, alpha), (radius, radius), radius)
            screen.blit(surf, (self.x - radius, self.y - radius))

class Board:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.size = GRID_SIZE
        self.grid = [['~' for _ in range(self.size)] for _ in range(self.size)]
        self.ships = []
        self.shots = set()
        self.animations = []
        self.hover_cell = None
    
    def place_ship(self, ship, row, col, horizontal):
        
        ship.coordinates = []
        
        
        if horizontal:
            if col + ship.size > self.size:
                return False
            for i in range(ship.size):
                if self.grid[row][col + i] != '~':
                    return False
            
            
            for i in range(ship.size):
                self.grid[row][col + i] = 'O'
                ship.coordinates.append((row, col + i))
        else:
            if row + ship.size > self.size:
                return False
            for i in range(ship.size):
                if self.grid[row + i][col] != '~':
                    return False
            
            
            for i in range(ship.size):
                self.grid[row + i][col] = 'O'
                ship.coordinates.append((row + i, col))
        
        self.ships.append(ship)
        ship.horizontal = horizontal
        ship.placed = True
        return True
    
    def place_ships_randomly(self, ships):
        for ship in ships:
            placed = False
            while not placed:
                row = random.randint(0, self.size - 1)
                col = random.randint(0, self.size - 1)
                horizontal = random.choice([True, False])
                placed = self.place_ship(ship, row, col, horizontal)
    
    def receive_shot(self, row, col):
        if (row, col) in self.shots:
            return "already_shot"
        
        self.shots.add((row, col))
        
        center_x = self.x + col * CELL_SIZE + CELL_SIZE // 2
        center_y = self.y + row * CELL_SIZE + CELL_SIZE // 2
        
        if self.grid[row][col] == 'O':
            self.grid[row][col] = 'X'
            
            self.animations.append(Explosion(center_x, center_y, True))
            
            for ship in self.ships:
                if (row, col) in ship.coordinates:
                    sunk = ship.hit()
                    if sunk:
                        return f"sunk_{ship.name}"
                    return "hit"
        else:
            self.grid[row][col] = 'M'
            
            self.animations.append(Explosion(center_x, center_y, False))
            return "miss"
    
    def all_ships_sunk(self):
        return all(ship.sunk for ship in self.ships)
    
    def update(self, dt, mouse_pos=None):
        
        self.animations = [anim for anim in self.animations if anim.update(dt)]
        
        
        if mouse_pos:
            if (self.x <= mouse_pos[0] <= self.x + self.size * CELL_SIZE and
                self.y <= mouse_pos[1] <= self.y + self.size * CELL_SIZE):
                grid_x = (mouse_pos[0] - self.x) // CELL_SIZE
                grid_y = (mouse_pos[1] - self.y) // CELL_SIZE
                self.hover_cell = (grid_y, grid_x)
            else:
                self.hover_cell = None
        else:
            self.hover_cell = None
    
    def draw(self, screen, hide_ships=False, selected_ship=None, is_horizontal=True):
        
        water_rect = pygame.Rect(self.x - 5, self.y - 5, 
                               self.size * CELL_SIZE + 10, self.size * CELL_SIZE + 10)
        pygame.draw.rect(screen, OCEAN, water_rect, border_radius=5)
        
        
        for i in range(0, self.size * CELL_SIZE, 10):
            alpha = random.randint(20, 60)
            wave_surf = pygame.Surface((self.size * CELL_SIZE, 3), pygame.SRCALPHA)
            pygame.draw.line(wave_surf, (255, 255, 255, alpha), (0, 1), (self.size * CELL_SIZE, 1), 2)
            screen.blit(wave_surf, (self.x, self.y + i))

        
        for row in range(self.size):
            for col in range(self.size):
                rect = pygame.Rect(
                    self.x + col * CELL_SIZE, 
                    self.y + row * CELL_SIZE,
                    CELL_SIZE, CELL_SIZE
                )
                pygame.draw.rect(screen, LIGHT_BLUE, rect)
                pygame.draw.rect(screen, GRAY, rect, 1)
                
                
                if (row, col) in self.shots:
                    if self.grid[row][col] == 'X':
                        
                        
                        pygame.draw.circle(
                            screen, RED,
                            (self.x + col * CELL_SIZE + CELL_SIZE // 2,
                             self.y + row * CELL_SIZE + CELL_SIZE // 2),
                            CELL_SIZE // 3
                        )
                        
                        
                        pygame.draw.line(
                            screen, BLACK,
                            (self.x + col * CELL_SIZE + 10, self.y + row * CELL_SIZE + 10),
                            (self.x + col * CELL_SIZE + CELL_SIZE - 10, 
                             self.y + row * CELL_SIZE + CELL_SIZE - 10), 2)
                        pygame.draw.line(
                            screen, BLACK,
                            (self.x + col * CELL_SIZE + CELL_SIZE - 10, self.y + row * CELL_SIZE + 10),
                            (self.x + col * CELL_SIZE + 10, 
                             self.y + row * CELL_SIZE + CELL_SIZE - 10), 2)
                    elif self.grid[row][col] == 'M':
                        
                        pygame.draw.circle(
                            screen, WHITE,
                            (self.x + col * CELL_SIZE + CELL_SIZE // 2,
                             self.y + row * CELL_SIZE + CELL_SIZE // 2),
                            CELL_SIZE // 4, 0
                        )
                        pygame.draw.circle(
                            screen, BLACK,
                            (self.x + col * CELL_SIZE + CELL_SIZE // 2,
                             self.y + row * CELL_SIZE + CELL_SIZE // 2),
                            CELL_SIZE // 4, 1
                        )
        
        
        if not hide_ships:
            for ship in self.ships:
                
                if len(ship.coordinates) > 0:  
                    if ship.horizontal:
                        start_row = ship.coordinates[0][0]
                        start_col = min(c for r, c in ship.coordinates)
                        ship.draw(screen, 
                                self.x + start_col * CELL_SIZE, 
                                self.y + start_row * CELL_SIZE, 
                                CELL_SIZE)
                    else:
                        start_row = min(r for r, c in ship.coordinates)
                        start_col = ship.coordinates[0][1]
                        ship.draw(screen, 
                                self.x + start_col * CELL_SIZE, 
                                self.y + start_row * CELL_SIZE, 
                                CELL_SIZE)
        
        
        for ship in self.ships:
            if ship.sunk:
                
                for row, col in ship.coordinates:
                    
                    rect_center = (
                        self.x + col * CELL_SIZE + CELL_SIZE // 2,
                        self.y + row * CELL_SIZE + CELL_SIZE // 2
                    )
                    
                    
                    
                    if not hide_ships or (row, col) in self.shots:
                        sunk_rect = pygame.Rect(
                            self.x + col * CELL_SIZE + 2, 
                            self.y + row * CELL_SIZE + 2,
                            CELL_SIZE - 4, CELL_SIZE - 4
                        )
                        pygame.draw.rect(screen, ORANGE, sunk_rect, 2, border_radius=3)
                    
                    
                    if not hide_ships:
                        small_font = pygame.font.Font(None, 28)
                        sunk_text = small_font.render("✓", True, ORANGE)
                        text_rect = sunk_text.get_rect(center=rect_center)
                        screen.blit(sunk_text, text_rect)
        
        
        if self.hover_cell and selected_ship:
            row, col = self.hover_cell
            
            can_place = True
            cells_to_highlight = []
            
            if is_horizontal:
                if col + selected_ship.size <= self.size:
                    for i in range(selected_ship.size):
                        if col + i < self.size:
                            cells_to_highlight.append((row, col + i))
                            if self.grid[row][col + i] != '~':
                                can_place = False
                else:
                    can_place = False
            else:
                if row + selected_ship.size <= self.size:
                    for i in range(selected_ship.size):
                        if row + i < self.size:
                            cells_to_highlight.append((row + i, col))
                            if self.grid[row + i][col] != '~':
                                can_place = False
                else:
                    can_place = False
            
            
            for cell_row, cell_col in cells_to_highlight:
                rect = pygame.Rect(
                    self.x + cell_col * CELL_SIZE, 
                    self.y + cell_row * CELL_SIZE,
                    CELL_SIZE, CELL_SIZE
                )
                placement_color = (0, 255, 0, 100) if can_place else (255, 0, 0, 100)
                
                s = pygame.Surface((CELL_SIZE, CELL_SIZE), pygame.SRCALPHA)
                s.fill(placement_color)
                screen.blit(s, rect)
        
        
        font = pygame.font.Font(None, FONT_SIZE)
        label_bg = (200, 200, 220, 180)
        
        for i in range(self.size):
            
            row_label = font.render(str(i+1), True, BLACK)
            label_rect = pygame.Rect(self.x - 25, self.y + i * CELL_SIZE + CELL_SIZE // 3 - 5, 20, 20)
            pygame.draw.rect(screen, label_bg, label_rect, border_radius=3)
            screen.blit(row_label, (self.x - 22, self.y + i * CELL_SIZE + CELL_SIZE // 3 - 2))
            
            
            col_label = font.render(chr(65 + i), True, BLACK)
            label_rect = pygame.Rect(self.x + i * CELL_SIZE + CELL_SIZE // 3 - 5, self.y - 25, 20, 20)
            pygame.draw.rect(screen, label_bg, label_rect, border_radius=3)
            screen.blit(col_label, (self.x + i * CELL_SIZE + CELL_SIZE // 3 - 2, self.y - 22))
        
        
        for anim in self.animations:
            anim.draw(screen)
        
        
        board_rect = pygame.Rect(self.x - 5, self.y - 5, 
                               self.size * CELL_SIZE + 10, self.size * CELL_SIZE + 10)
        pygame.draw.rect(screen, NAVY, board_rect, 3, border_radius=5)

class Button:
    def __init__(self, x, y, width, height, text, color, hover_color, text_color=BLACK, action=None):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color
        self.hover_color = hover_color
        self.text_color = text_color
        self.action = action
        self.is_hovered = False
        
    def update(self, mouse_pos):
        self.is_hovered = self.rect.collidepoint(mouse_pos)
    
    def draw(self, screen, font):
        
        color = self.hover_color if self.is_hovered else self.color
        
        
        pygame.draw.rect(screen, color, self.rect, 0, border_radius=8)
        
        shadow_rect = pygame.Rect(self.rect.x + 2, self.rect.y + 2, 
                                self.rect.width, self.rect.height)
        pygame.draw.rect(screen, (50, 50, 50), shadow_rect, 0, border_radius=8)
        pygame.draw.rect(screen, color, self.rect, 0, border_radius=8)
        
        
        pygame.draw.rect(screen, BLACK, self.rect, 2, border_radius=8)
        
        
        text_surf = font.render(self.text, True, self.text_color)
        text_rect = text_surf.get_rect(center=self.rect.center)
        screen.blit(text_surf, text_rect)
    
    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.is_hovered and self.action:
                return self.action()
        return False

class ShipStatusDisplay:
    def __init__(self, x, y, player_num):
        self.x = x
        self.y = y
        self.player_num = player_num
        self.width = 180
        self.height = 200
        self.padding = 10
        
    def draw(self, screen, font, ships, opponent=False):
        # Draw background panel
        panel_rect = pygame.Rect(self.x, self.y, self.width, self.height)
        pygame.draw.rect(screen, LIGHT_GRAY, panel_rect, 0, border_radius=8)
        pygame.draw.rect(screen, GRAY, panel_rect, 2, border_radius=8)
        
        # Draw title
        title = f"Player {self.player_num}'s Ships"
        if opponent:
            title = f"Opponent's Ships"
        
        title_surf = font.render(title, True, BLACK)
        screen.blit(title_surf, (self.x + self.padding, self.y + self.padding))
        
        # Draw horizontal line
        pygame.draw.line(screen, GRAY, 
                       (self.x + self.padding, self.y + self.padding + 25),
                       (self.x + self.width - self.padding, self.y + self.padding + 25), 2)
        
        # Draw ship status
        y_offset = self.y + self.padding + 35
        for ship in ships:
            # Draw ship name
            ship_name = font.render(ship.name, True, BLACK)
            screen.blit(ship_name, (self.x + self.padding, y_offset))
            
            # Draw ship status (sunk or active)
            status_color = RED if ship.sunk else GREEN
            status_text = "Sunk" if ship.sunk else "Active"
            status_surf = font.render(status_text, True, status_color)
            screen.blit(status_surf, (self.x + self.width - status_surf.get_width() - self.padding, y_offset))
            
            # Draw hit counter
            hit_text = f"{ship.hits}/{ship.size}"
            hit_surf = font.render(hit_text, True, BLACK)
            screen.blit(hit_surf, (self.x + self.width // 2, y_offset))
            
            y_offset += 25

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Naval Battle")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, FONT_SIZE)
        self.big_font = pygame.font.Font(None, 48)
        
        self.state = MENU
        self.current_player = 1
        self.selected_ship = None
        self.ship_horizontal = True
        self.winner = None
        self.message = ""
        self.message_timer = 0
        
        # Create menu buttons
        self.menu_buttons = [
            Button(250, 250, 500, 50, "Player vs Player", LIGHT_BLUE, BLUE, BLACK, 
                  lambda: self.start_pvp_game()),
            Button(250, 300, 500, 50, "Player vs AI", LIGHT_BLUE, BLUE, BLACK, 
                  lambda: self.start_ai_game()),
            Button(250, 350, 500, 50, "Start with Random Ship Placement", LIGHT_BLUE, BLUE, BLACK, 
                  lambda: self.start_random_game()),
            Button(250, 650, 500, 50, "Quit", RED, (200, 0, 0), WHITE, 
                  lambda: self.quit_game())
        ]
        
        # Create gameplay buttons
        self.gameplay_buttons = []
        
        # Initialize new game elements
        self.reset_game()
        
        # Add ship status displays
        self.status_display1 = ShipStatusDisplay(50, 480, 1)
        self.status_display2 = ShipStatusDisplay(SCREEN_WIDTH - 230, 480, 2)
        
        # Track mouse position
        self.mouse_pos = (0, 0)

        # Online game variables
        self.network = None
        self.is_online_game = False
        self.online_player_num = None
        self.opponent_name = "Opponent"
        self.active_input_field = None  # Can be "ip", "port", or "name"
        self.server_ip_input = "127.0.0.1"
        self.server_port_input = "8888"
        self.player_name_input = "Player"
        self.connection_status = ""
        
        # Ajouter un bouton pour le mode en ligne
        self.menu_buttons.append(
            Button(250, 400, 500, 50, "Online Multiplayer", LIGHT_BLUE, BLUE, BLACK, 
                   lambda: self.show_connect_screen())
        )
    
    def start_pvp_game(self):
        self.state = SETUP
        self.setup_complete = [False, False]
        self.message = "Player 1: Place your ships!"
        self.message_timer = 3000
        return True
    
    def start_ai_game(self):
        """Start a game against the AI opponent"""
        self.reset_game()
        self.is_ai_game = True
        self.ai_player = 2  # AI will be player 2
        
        # Initialize the AI with the trained model
        model_path = "battleship_drl_model.pth"  # Use your best model here
        if os.path.exists(model_path):
            self.ai = BattleshipAI(model_path)
            print(f"AI loaded from {model_path}")
        else:
            print(f"Warning: Model file {model_path} not found. Using default AI.")
            self.ai = BattleshipAI()
        
        # Setup initial state - player 1 places ships first
        self.state = SETUP
        self.current_player = 1
        self.message = "Place your ships against the AI opponent!"
        self.message_timer = 3000
        return True
    
    def start_random_game(self):
        self.state = SETUP
        self.board1.place_ships_randomly(self.ships1)
        self.board2.place_ships_randomly(self.ships2)
        self.setup_complete = [True, True]
        self.state = GAMEPLAY
        self.current_player = 1
        self.message = "Game started! Player 1's turn"
        self.message_timer = 3000
        return True
    
    def quit_game(self):
        pygame.quit()
        sys.exit()
    
    def reset_game(self):
        # Create boards
        self.board1 = Board(GRID_PADDING, GRID_PADDING)
        self.board2 = Board(SCREEN_WIDTH // 2 + GRID_PADDING, GRID_PADDING)
        
        # Create ships for both players
        self.ships1 = [
            Ship(5, "Carrier"),
            Ship(4, "Battleship"),
            Ship(3, "Cruiser"),
            Ship(3, "Submarine"),
            Ship(2, "Destroyer")
        ]
        self.ships2 = [
            Ship(5, "Carrier"),
            Ship(4, "Battleship"),
            Ship(3, "Cruiser"),
            Ship(3, "Submarine"),
            Ship(2, "Destroyer")
        ]
        
        self.remaining_ships1 = self.ships1.copy()
        self.remaining_ships2 = self.ships2.copy()
        self.selected_ship = None
        self.ship_horizontal = True
        self.current_player = 1
        self.winner = None
        self.setup_complete = [False, False]
        
        # Setup buttons
        self.setup_buttons = [
            Button(825, 350, 100, 50, "Rotate", GREEN, (0, 220, 0), BLACK, 
                  lambda: self.rotate_ship()),
            Button(825, 450, 100, 50, "Random", YELLOW, (220, 220, 0), BLACK, 
                  lambda: self.random_placement())
        ]
        
        # Game over buttons
        self.gameover_buttons = [
            Button(400, 400, 200, 50, "New Game", GREEN, (0, 220, 0), BLACK, 
                  lambda: self.new_game())
        ]
        
        # Add at the end of reset_game method
        self.is_ai_game = False
        self.ai = None
        self.ai_player = None
        self.ai_thinking = False
        self.ai_move_timer = 0
    
    def rotate_ship(self):
        if self.selected_ship:
            self.ship_horizontal = not self.ship_horizontal
            self.message = "Ship rotated"
            self.message_timer = 1000
            return True
        return False
    
    def random_placement(self):
        if self.current_player == 1:
            board = self.board1
            remaining_ships = self.remaining_ships1
        else:
            board = self.board2
            remaining_ships = self.remaining_ships2
            
        board.place_ships_randomly(remaining_ships)
        remaining_ships.clear()
        self.selected_ship = None
        self.setup_complete[self.current_player - 1] = True
        
        if self.current_player == 1:
            self.current_player = 2
            self.message = "Player 2: Place your ships!"
            self.message_timer = 3000
        else:
            self.state = GAMEPLAY
            self.current_player = 1
            self.message = "Game started! Player 1's turn"
            self.message_timer = 3000
        return True
    
    def new_game(self):
        self.reset_game()
        self.state = MENU
        return True
    
    def handle_setup_click(self, pos):
        # Déterminer quel plateau et quels navires utiliser
        if self.is_online_game:
            # En mode en ligne, chaque joueur ne peut interagir qu'avec son propre plateau
            if self.online_player_num == 1:
                board = self.board1
                remaining_ships = self.remaining_ships1
            else:  # Player 2
                board = self.board2
                remaining_ships = self.remaining_ships2
        else:
            # Pour les modes non-en ligne, conserver le comportement existant
            if self.current_player == 1:
                board = self.board1
                remaining_ships = self.remaining_ships1
            else:
                board = self.board2
                remaining_ships = self.remaining_ships2
        
        # Check if any setup buttons were clicked
        for button in self.setup_buttons:
            if button.handle_event(pygame.event.Event(pygame.MOUSEBUTTONDOWN, 
                                                    {'pos': pos, 'button': 1})):
                return
        
        # Check if the click is within the board
        if (board.x <= pos[0] <= board.x + board.size * CELL_SIZE and
            board.y <= pos[1] <= board.y + board.size * CELL_SIZE):
            
            # Calculate grid position
            grid_x = (pos[0] - board.x) // CELL_SIZE
            grid_y = (pos[1] - board.y) // CELL_SIZE
            
            # Try to place selected ship
            if self.selected_ship:
                if board.place_ship(self.selected_ship, grid_y, grid_x, self.ship_horizontal):
                    old_ship = self.selected_ship  # Save reference
                    remaining_ships.remove(self.selected_ship)
                    self.selected_ship = None if not remaining_ships else remaining_ships[0]
                    
                    # For online mode, notify the server about ship placement
                    if self.is_online_game:
                        self.network.send_message({
                            "type": "ship_placement",
                            "player_num": self.online_player_num,
                            "ship": {
                                "name": old_ship.name,
                                "size": old_ship.size,
                                "row": grid_y,
                                "col": grid_x,
                                "horizontal": self.ship_horizontal
                            }
                        })
                    
                    # Check if all ships are placed
                    if not remaining_ships:
                        self.setup_complete[self.current_player - 1] = True
                        
                        # Handle online setup completion
                        if self.is_online_game:
                            self.network.send_message({
                                "type": "setup_complete",
                                "player_num": self.online_player_num
                            })
                            self.message = "Waiting for opponent to finish setup..."
                            self.message_timer = 3000
                        elif self.current_player == 1:
                            if self.is_ai_game:
                                # AI setup - automatically place ships randomly
                                self.board2.place_ships_randomly(self.ships2)
                                self.setup_complete[1] = True
                                self.state = GAMEPLAY
                                self.current_player = 1
                                self.message = "Game started! Your turn"
                                self.message_timer = 3000
                            else:
                                # Regular PvP setup
                                self.current_player = 2
                                self.message = "Player 2: Place your ships!"
                                self.message_timer = 3000
                        else:
                            self.state = GAMEPLAY
                            self.current_player = 1
                            self.message = "Game started! Player 1's turn"
                            self.message_timer = 3000
                else:
                    self.message = "Cannot place ship here!"
                    self.message_timer = 2000
        
        # Check if ship selection buttons were clicked
        if 800 <= pos[0] <= 950:
            for i, ship in enumerate(remaining_ships):
                if 150 + i * 50 <= pos[1] <= 190 + i * 50:
                    self.selected_ship = ship
                    self.message = f"Selected {ship.name} (size {ship.size})"
                    self.message_timer = 2000
    
    def handle_gameplay_click(self, pos):
        # Prevent clicks when it's not your turn in online mode
        if self.is_online_game and self.current_player != self.online_player_num:
            self.message = "Not your turn!"
            self.message_timer = 2000
            return
        
        # For AI games, prevent clicks during AI's turn
        if self.is_ai_game and self.current_player == self.ai_player:
            return

        # Determine which board to target
        target_board = self.board2 if self.current_player == 1 else self.board1
        
        # Check if the click is within the target board
        if (target_board.x <= pos[0] <= target_board.x + target_board.size * CELL_SIZE and
            target_board.y <= pos[1] <= target_board.y + target_board.size * CELL_SIZE):
            
            # Calculate grid position
            grid_x = (pos[0] - target_board.x) // CELL_SIZE
            grid_y = (pos[1] - target_board.y) // CELL_SIZE
            
            # For online gameplay, send shot to server
            if self.is_online_game:
                self.network.send_message({
                    "type": "shot",
                    "player_num": self.online_player_num,
                    "row": grid_y,
                    "col": grid_x
                })
                return
            
            # Process shot locally for non-online games
            result = target_board.receive_shot(grid_y, grid_x)
            
            if result == "already_shot":
                self.message = "You already shot there!"
                self.message_timer = 2000
            else:
                if result == "hit":
                    self.message = "Hit!"
                    self.message_timer = 2000
                elif result == "miss":
                    self.message = "Miss!"
                    self.message_timer = 2000
                    # Switch players
                    self.current_player = 3 - self.current_player  # Toggle between 1 and 2
                elif result.startswith("sunk"):
                    ship_name = result.split("_")[1]
                    self.message = f"You sunk the {ship_name}!"
                    self.message_timer = 3000
                
                # Check for win condition
                if target_board.all_ships_sunk():
                    self.winner = self.current_player
                    self.state = GAME_OVER
    
    def handle_game_over_click(self, pos):
        for button in self.gameover_buttons:
            if button.handle_event(pygame.event.Event(pygame.MOUSEBUTTONDOWN, 
                                                  {'pos': pos, 'button': 1})):
                return
    
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            elif event.type == pygame.MOUSEMOTION:
                self.mouse_pos = event.pos
                # Update button hover states
                if self.state == MENU:
                    for button in self.menu_buttons:
                        button.update(event.pos)
                elif self.state == SETUP:
                    for button in self.setup_buttons:
                        button.update(event.pos)
                elif self.state == GAME_OVER:
                    for button in self.gameover_buttons:
                        button.update(event.pos)
            
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:  # Left mouse button
                    if self.state == MENU:
                        for button in self.menu_buttons:
                            if button.handle_event(event):
                                break
                    elif self.state == SETUP:
                        self.handle_setup_click(event.pos)
                    elif self.state == GAMEPLAY:
                        self.handle_gameplay_click(event.pos)
                    elif self.state == GAME_OVER:
                        self.handle_game_over_click(event.pos)
                    elif self.state == ONLINE_SETUP:
                        # First check for buttons
                        button_clicked = False
                        for x, y, w, h, action in [
                            (SCREEN_WIDTH // 2 - 75, 350, 150, 40, self.connect_to_server),  # Connect
                            (50, SCREEN_HEIGHT - 70, 100, 40, self.back_to_menu)  # Back
                        ]:
                            if x <= event.pos[0] <= x + w and y <= event.pos[1] <= y + h:
                                action()
                                button_clicked = True
                                break
                        
                        # If no button clicked, check for text fields
                        if not button_clicked:
                            self.handle_connect_screen_click(event.pos)
                            
                    elif self.state == ONLINE_WAITING:
                        # Check for cancel button
                        if (SCREEN_WIDTH // 2 - 75 <= event.pos[0] <= SCREEN_WIDTH // 2 + 75 and
                            400 <= event.pos[1] <= 440):
                            self.back_to_menu()
            
            elif event.type == pygame.KEYDOWN:
                # Add keyboard shortcut for rotation (R key)
                if event.key == pygame.K_r and self.state == SETUP and self.selected_ship:
                    self.rotate_ship()
                
                # Handle text input for online setup
                if self.state == ONLINE_SETUP:
                    self.handle_connect_screen_event(event)
    
    def draw_menu(self):
        # Create lighter gradient background
        self.screen.fill(WHITE)
        for y in range(SCREEN_HEIGHT):
            color = (
                int(200 + (55 * y / SCREEN_HEIGHT)),  # Lighter red
                int(220 + (35 * y / SCREEN_HEIGHT)),  # Lighter green
                int(240 + (15 * y / SCREEN_HEIGHT))   # Lighter blue
            )
            pygame.draw.line(self.screen, color, (0, y), (SCREEN_WIDTH, y))
        
        # Draw title with shadow effect
        title_shadow = self.big_font.render("NAVAL BATTLE", True, BLACK)
        title = self.big_font.render("NAVAL BATTLE", True, BLUE)
        self.screen.blit(title_shadow, (SCREEN_WIDTH // 2 - title.get_width() // 2 + 2, 102))
        self.screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 100))
        
        # Draw subtitle
        subtitle = self.font.render("Battleship Strategy Game", True, NAVY)
        self.screen.blit(subtitle, (SCREEN_WIDTH // 2 - subtitle.get_width() // 2, 160))
        
        # Draw buttons with better visibility
        for button in self.menu_buttons:
            button.draw(self.screen, self.font)
        
        # Draw decorative ships
        ship1 = Ship(4, "Battleship")
        ship1.draw(self.screen, 100, 300, 40, False)
        
        ship2 = Ship(3, "Cruiser")
        ship2.horizontal = False
        ship2.draw(self.screen, 850, 350, 40, False)
    
    def draw_setup(self):
        # Create gradient background
        for y in range(SCREEN_HEIGHT):
            color = (220, 230, 240, 255)
            pygame.draw.rect(self.screen, color, (0, y, SCREEN_WIDTH, 1))
        
        # Déterminer quel joueur et quel plateau afficher
        if self.is_online_game:
            # En mode en ligne, chaque joueur voit uniquement son plateau
            if self.online_player_num == 1:
                title = f"Player 1: Place Your Ships (vs {self.opponent_name})"
                board = self.board1
                remaining_ships = self.remaining_ships1
            else:  # Player 2
                title = f"Player 2: Place Your Ships (vs {self.opponent_name})"
                board = self.board2
                remaining_ships = self.remaining_ships2
        else:
            # Pour les autres modes, conserver le comportement existant
            if self.current_player == 1:
                title = "Player 1: Place Your Ships"
                board = self.board1
                remaining_ships = self.remaining_ships1
            else:
                title = "Player 2: Place Your Ships"
                board = self.board2
                remaining_ships = self.remaining_ships2
        
        # Draw setup title with shadow
        title_shadow = self.font.render(title, True, BLACK)
        title_text = self.font.render(title, True, BLUE)
        self.screen.blit(title_shadow, (SCREEN_WIDTH // 2 - title_text.get_width() // 2 + 1, 11))
        self.screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, 10))
        
        mouse_pos = pygame.mouse.get_pos()
        
        board.update(self.clock.get_time(), mouse_pos)
        board.draw(self.screen, hide_ships=False, selected_ship=self.selected_ship, 
                 is_horizontal=self.ship_horizontal)
        
        # Déterminer si c'est le plateau de gauche ou de droite et positionner le panneau en conséquence
        is_left_board = (board == self.board1)
        
        # Calculer la position du panneau latéral
        if is_left_board:
            # Si c'est le plateau de gauche, positionner le panneau à droite du plateau
            sidebar_x = board.x + (CELL_SIZE * GRID_SIZE) + 50  # 50px de marge
        else:
            # Si c'est le plateau de droite, positionner le panneau à l'extrémité gauche
            sidebar_x = 50  # 50px de la bordure gauche de l'écran
        
        # Draw ship selection sidebar à la nouvelle position
        pygame.draw.rect(self.screen, LIGHT_BLUE, (sidebar_x, 100, 150, 400), 0, border_radius=8)
        pygame.draw.rect(self.screen, NAVY, (sidebar_x, 100, 150, 400), 2, border_radius=8)
        ship_select_text = self.font.render("Select Ship:", True, BLACK)
        self.screen.blit(ship_select_text, (sidebar_x + 25, 110))
        
        # Draw available ships avec la nouvelle position
        for i, ship in enumerate(remaining_ships):
            is_selected = self.selected_ship == ship
            ship.draw(self.screen, sidebar_x + 25, 150 + i * 50, 20, is_selected)
            ship_name = self.font.render(ship.name, True, BLACK)
            self.screen.blit(ship_name, (sidebar_x + 25 + ship.size * 20 + 10, 160 + i * 50))
        
        # Draw setup buttons (rotate & random) avec la nouvelle position
        self.setup_buttons[0].rect.x = sidebar_x + 25  # Bouton Rotate
        self.setup_buttons[0].rect.y = 350  # Maintenir la position Y
        self.setup_buttons[1].rect.x = sidebar_x + 25  # Bouton Random
        self.setup_buttons[1].rect.y = 450  # Maintenir la position Y
        
        for button in self.setup_buttons:
            button.draw(self.screen, self.font)
        
        # Afficher l'orientation avec la nouvelle position
        orientation = "Horizontal" if self.ship_horizontal else "Vertical"
        orientation_text = self.font.render(f"Orientation: {orientation}", True, BLACK)
        self.screen.blit(orientation_text, (sidebar_x + 25, 500))
    
    def draw_gameplay(self):
        
        if self.is_online_game:
            
            if self.current_player == self.online_player_num:
                current_text = self.big_font.render("YOUR TURN", True, GREEN)
            else:
                current_text = self.big_font.render(f"{self.opponent_name}'S TURN", True, RED)
                
            
            my_board = self.board1 if self.online_player_num == 1 else self.board2
            opponent_board = self.board2 if self.online_player_num == 1 else self.board1
            
            
            if self.current_player == self.online_player_num:
                
                my_board.update(self.clock.get_time())
                opponent_board.update(self.clock.get_time(), self.mouse_pos)
            else:
                
                my_board.update(self.clock.get_time())
                opponent_board.update(self.clock.get_time())
            
            
            my_label = self.font.render("YOUR BOARD", True, NAVY)
            opp_label = self.font.render(f"{self.opponent_name}'S BOARD", True, NAVY)
            
            
            self.screen.blit(my_label, (my_board.x + my_board.size * CELL_SIZE // 2 - my_label.get_width() // 2, my_board.y - 40))
            self.screen.blit(opp_label, (opponent_board.x + opponent_board.size * CELL_SIZE // 2 - opp_label.get_width() // 2, opponent_board.y - 40))
            
            
            my_board.draw(self.screen, hide_ships=False)  
            opponent_board.draw(self.screen, hide_ships=True)  
            
            
            if self.online_player_num == 1:
                self.status_display1.draw(self.screen, self.font, self.ships1, opponent=False)
                self.status_display2.draw(self.screen, self.font, self.ships2, opponent=True)
            else:
                self.status_display1.draw(self.screen, self.font, self.ships1, opponent=True)
                self.status_display2.draw(self.screen, self.font, self.ships2, opponent=False)
        else:
            
            if self.is_ai_game:
                current_text = self.big_font.render("Your Turn" if self.current_player == 1 else "AI's Turn", True, RED)
                self.board1.draw(self.screen, hide_ships=False)  # Player's ships always visible
                self.board2.draw(self.screen, hide_ships=True)   # AI's ships always hidden
            else:
                current_text = self.big_font.render(f"Player {self.current_player}'s Turn", True, RED)
                self.board1.draw(self.screen, hide_ships=self.current_player == 2)
                self.board2.draw(self.screen, hide_ships=self.current_player == 1)
            
            # Dessiner l'affichage de statut des navires
            self.status_display1.draw(self.screen, self.font, self.ships1, opponent=self.current_player == 2)
            self.status_display2.draw(self.screen, self.font, self.ships2, opponent=self.current_player == 1)
        
        # Draw message
        if self.message and self.message_timer > 0:
            msg_text = self.font.render(self.message, True, BLACK)
            msg_bg = pygame.Rect(SCREEN_WIDTH // 2 - msg_text.get_width() // 2 - 10, 650,
                              msg_text.get_width() + 20, 30)
            pygame.draw.rect(self.screen, (255, 255, 200), msg_bg, 0, border_radius=5)
            pygame.draw.rect(self.screen, BLACK, msg_bg, 1, border_radius=5)
            self.screen.blit(msg_text, (SCREEN_WIDTH // 2 - msg_text.get_width() // 2, 655))
        
        # Afficher le texte indiquant le tour actuel
        self.screen.blit(current_text, (SCREEN_WIDTH // 2 - current_text.get_width() // 2, 600))
    
    def draw_game_over(self):
        # Create gradient background
        for y in range(SCREEN_HEIGHT):
            r = int(150 + (100 * (1 - y / SCREEN_HEIGHT)))
            g = int(150 + (100 * (1 - y / SCREEN_HEIGHT)))
            b = int(200 + (55 * (1 - y / SCREEN_HEIGHT)))
            pygame.draw.rect(self.screen, (r, g, b), (0, y, SCREEN_WIDTH, 1))
        
        # Draw confetti particles
        for _ in range(10):
            x = random.randint(0, SCREEN_WIDTH)
            y = random.randint(0, SCREEN_HEIGHT)
            size = random.randint(3, 10)
            color = random.choice([RED, GREEN, BLUE, YELLOW])
            pygame.draw.rect(self.screen, color, (x, y, size, size))
        
        # Draw game over message with shadow effect
        game_over_shadow = self.big_font.render("GAME OVER", True, BLACK)
        game_over_text = self.big_font.render("GAME OVER", True, RED)
        
        # Update winner text in draw_game_over
        if self.is_ai_game and self.winner == self.ai_player:
            winner_text = self.big_font.render("AI Wins!", True, BLUE)
            winner_shadow = self.big_font.render("AI Wins!", True, BLACK)
        elif self.is_ai_game:
            winner_text = self.big_font.render("You Win!", True, BLUE)
            winner_shadow = self.big_font.render("You Win!", True, BLACK)
        else:
            winner_text = self.big_font.render(f"Player {self.winner} Wins!", True, BLUE)
            winner_shadow = self.big_font.render(f"Player {self.winner} Wins!", True, BLACK)
        
        # Draw shadow text slightly offset
        self.screen.blit(game_over_shadow, (SCREEN_WIDTH // 2 - game_over_text.get_width() // 2 + 2, 202))
        self.screen.blit(winner_shadow, (SCREEN_WIDTH // 2 - winner_text.get_width() // 2 + 2, 302))
        
        # Draw main text
        self.screen.blit(game_over_text, (SCREEN_WIDTH // 2 - game_over_text.get_width() // 2, 200))
        self.screen.blit(winner_text, (SCREEN_WIDTH // 2 - winner_text.get_width() // 2, 300))
        
        # Draw buttons
        for button in self.gameover_buttons:
            button.draw(self.screen, self.font)
    
    def draw_connect_screen(self):
        """Draw the connection setup screen"""
        # Background
        self.screen.fill(LIGHT_BLUE)
        
        # Title
        title = self.big_font.render("Online Multiplayer", True, NAVY)
        self.screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 50))
        
        # Connection form
        form_width = 400
        form_height = 300
        form_x = SCREEN_WIDTH // 2 - form_width // 2
        form_y = 150
        
        pygame.draw.rect(self.screen, WHITE, (form_x, form_y, form_width, form_height), 0, border_radius=10)
        pygame.draw.rect(self.screen, NAVY, (form_x, form_y, form_width, form_height), 2, border_radius=10)
        
        # Form fields
        y_offset = form_y + 30
        
        # Server IP
        ip_label = self.font.render("Server IP:", True, BLACK)
        self.screen.blit(ip_label, (form_x + 30, y_offset))
        
        # IP input field - highlight if active
        ip_field_color = YELLOW if self.active_input_field == "ip" else LIGHT_GRAY
        pygame.draw.rect(self.screen, ip_field_color, (form_x + 150, y_offset - 5, 200, 30), 0, border_radius=5)
        ip_text = self.font.render(self.server_ip_input, True, BLACK)
        self.screen.blit(ip_text, (form_x + 160, y_offset))
        
        # Server Port
        y_offset += 50
        port_label = self.font.render("Server Port:", True, BLACK)
        self.screen.blit(port_label, (form_x + 30, y_offset))
        
        # Port input field - highlight if active
        port_field_color = YELLOW if self.active_input_field == "port" else LIGHT_GRAY
        pygame.draw.rect(self.screen, port_field_color, (form_x + 150, y_offset - 5, 200, 30), 0, border_radius=5)
        port_text = self.font.render(self.server_port_input, True, BLACK)
        self.screen.blit(port_text, (form_x + 160, y_offset))
        
        # Player Name
        y_offset += 50
        name_label = self.font.render("Your Name:", True, BLACK)
        self.screen.blit(name_label, (form_x + 30, y_offset))
        
        # Name input field - highlight if active
        name_field_color = YELLOW if self.active_input_field == "name" else LIGHT_GRAY
        pygame.draw.rect(self.screen, name_field_color, (form_x + 150, y_offset - 5, 200, 30), 0, border_radius=5)
        name_text = self.font.render(self.player_name_input, True, BLACK)
        self.screen.blit(name_text, (form_x + 160, y_offset))
        
        # Connect button
        y_offset += 80
        connect_button = Button(
            form_x + form_width // 2 - 75, y_offset,
            150, 40, "Connect", GREEN, (0, 200, 0), WHITE,
            lambda: self.connect_to_server()
        )
        connect_button.update(self.mouse_pos)
        connect_button.draw(self.screen, self.font)
        
        # Back button
        back_button = Button(
            50, SCREEN_HEIGHT - 70,
            100, 40, "Back", RED, (200, 0, 0), WHITE,
            lambda: self.back_to_menu()
        )
        back_button.update(self.mouse_pos)
        back_button.draw(self.screen, self.font)
        
        # Status message
        status_text = self.font.render(self.connection_status, True, RED)
        self.screen.blit(status_text, (SCREEN_WIDTH // 2 - status_text.get_width() // 2, form_y + form_height + 20))
    
    def draw_waiting_screen(self):
        """Draw waiting for opponent screen"""
        self.screen.fill(LIGHT_BLUE)
        
        # Title
        title = self.big_font.render("Waiting for Opponent", True, NAVY)
        self.screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 200))
        
        # Animated dots for waiting indicator
        dots = "." * (int(pygame.time.get_ticks() / 500) % 4)
        waiting_text = self.big_font.render(f"Please wait{dots}", True, BLACK)
        self.screen.blit(waiting_text, (SCREEN_WIDTH // 2 - waiting_text.get_width() // 2, 300))
        
        # Cancel button
        cancel_button = Button(
            SCREEN_WIDTH // 2 - 75, 400,
            150, 40, "Cancel", RED, (200, 0, 0), WHITE,
            lambda: self.back_to_menu()
        )
        cancel_button.update(self.mouse_pos)
        cancel_button.draw(self.screen, self.font)
    
    def update(self):
        # Update message timer
        if self.message_timer > 0:
            self.message_timer -= self.clock.get_time()
            if self.message_timer <= 0:
                self.message = ""
        
        # Update boards
        dt = self.clock.get_time()
        mouse_pos = pygame.mouse.get_pos()
        
        # In setup phase, only update the active player's board
        if self.state == SETUP:
            if self.current_player == 1:
                self.board1.update(dt, mouse_pos)
                self.board2.update(dt)
            else:
                self.board1.update(dt)
                self.board2.update(dt, mouse_pos)
        
        # Add this at the beginning of the update method after message timer code
        # Around line 730-750
        if self.state == GAMEPLAY and self.is_ai_game and self.current_player == self.ai_player:
            # Add a delay to make the AI's move feel more natural
            self.ai_move_timer += self.clock.get_time()
            if self.ai_move_timer >= 800:  # 800ms delay
                self.ai_move_timer = 0
                self.make_ai_move()
    
    def make_ai_move(self):
        """Execute the AI's turn"""
        # Create board adapter for the AI
        board_adapter = self.create_board_adapter(self.board1)
        
        # Get AI's choice of shot
        row, col = self.ai.choose_shot(board_adapter)
        
        # Process the shot
        result = self.board1.receive_shot(row, col)
        
        # Update message based on result
        if result == "already_shot":
            # This shouldn't happen with a properly trained AI
            print("AI tried to shoot at an already targeted position!")
            # Try again
            self.make_ai_move()
            return
        elif result == "hit":
            self.message = "AI hit your ship!"
            self.message_timer = 2000
        elif result == "miss":
            self.message = "AI missed!"
            self.message_timer = 2000
            # Switch back to player's turn
            self.current_player = 1
        elif result.startswith("sunk"):
            ship_name = result.split("_")[1]
            self.message = f"AI sunk your {ship_name}!"
            self.message_timer = 3000
        
        # Check for win condition
        if self.board1.all_ships_sunk():
            self.winner = self.ai_player
            self.state = GAME_OVER
    
    def create_board_adapter(self, game_board):
        """Create an adapter that converts the game board to AI format"""
        class BoardAdapter:
            def __init__(self, game_board):
                self.size = 10
                self.grid = game_board.grid
                self.ships = game_board.ships
                self.shots = set()
                self.hits = set()
                self.misses = set()
                self.sunk_ships = []
                
                # Extract data from the game board
                for r in range(self.size):
                    for c in range(self.size):
                        if (r, c) in game_board.shots:
                            self.shots.add((r, c))
                            if game_board.grid[r][c] == 'X':
                                self.hits.add((r, c))
                            elif game_board.grid[r][c] == 'M':
                                self.misses.add((r, c))
                
                # Add sunk ships info
                self.sunk_ships = [ship for ship in game_board.ships if ship.sunk]
                
            def get_valid_actions(self):
                """Get all valid positions to shoot at"""
                valid = []
                for r in range(self.size):
                    for c in range(self.size):
                        if (r, c) not in self.shots:
                            valid.append((r, c))
                return valid
        
        return BoardAdapter(game_board)
    
    def show_connect_screen(self):
        """Switch to online connection setup screen"""
        self.state = ONLINE_SETUP
        return True

    def connect_to_server(self):
        """Connect to the battleship server"""
        try:
            # Import connection client here to avoid circular imports
            from client import NetworkClient
            
            self.connection_status = "Connecting..."
            
            # Create network client and connect
            self.network = NetworkClient(self.handle_network_message)
            connection_success = self.network.connect(
                self.server_ip_input, 
                int(self.server_port_input), 
                self.player_name_input
            )
            
            if connection_success:
                self.connection_status = "Connected! Waiting for opponent..."
                self.is_online_game = True
                self.state = ONLINE_WAITING
                return True
            else:
                self.connection_status = "Connection failed!"
                return False
        except Exception as e:
            self.connection_status = f"Error: {str(e)}"
            return False

    def handle_network_message(self, message):
        """Process messages from the server"""
        message_type = message.get("type")
        print(f"Received message: {message_type}")
        
        if message_type == "connected":
            self.connection_status = "Connected to server"
        
        elif message_type == "session_start":
            # Session started, get player info
            self.online_player_num = message.get("player_num")
            self.opponent_name = message.get("opponent", "Opponent")
            
            # Reset game and set up for online play
            self.reset_game()
            self.is_online_game = True
            self.state = SETUP
            
            # Set message based on player number
            self.message = f"You are Player {self.online_player_num}. Place your ships!"
            self.message_timer = 3000
        
        elif message_type == "waiting_for_opponent":
            self.state = ONLINE_WAITING
            self.connection_status = "Waiting for an opponent..."
        
        elif message_type == "gameplay_start":
            self.state = GAMEPLAY
            self.current_player = message.get("current_player", 1)
            self.message = "Game started!"
            self.message_timer = 3000
        
        elif message_type == "receive_shot":
            row = message.get("row")
            col = message.get("col")
            player = message.get("player")
            
            # Process shot on your board
            my_board = self.board1 if self.online_player_num == 1 else self.board2
            result = my_board.receive_shot(row, col)
            
            # Send result back to server
            self.network.send_message({
                "type": "shot_result",
                "player_num": player,
                "row": row,
                "col": col,
                "result": result
            })
        
        elif message_type == "shot_result":
            player = message.get("player")
            row = message.get("row")
            col = message.get("col")
            result = message.get("result")
            
            # Update message based on result
            if player == self.online_player_num:
                attacker = "You"
            else:
                attacker = "Opponent"
                
            if result == "hit":
                self.message = f"{attacker} hit!"
                self.message_timer = 2000
            elif result == "miss":
                self.message = f"{attacker} missed!"
                self.message_timer = 2000
            elif result.startswith("sunk"):
                ship_name = result.split("_")[1]
                self.message = f"{attacker} sunk the {ship_name}!"
                self.message_timer = 3000
        
        elif message_type == "turn_change":
            self.current_player = message.get("current_player")
            if self.current_player == self.online_player_num:
                self.message = "Your turn!"
            else:
                self.message = "Opponent's turn!"
            self.message_timer = 2000
        
        elif message_type == "game_over":
            winner = message.get("winner")
            self.winner = winner
            self.state = GAME_OVER
        
        elif message_type == "error":
            self.connection_status = message.get("message", "Unknown error")

    def back_to_menu(self):
        """Return to main menu"""
        self.state = MENU
        
        # Disconnect if connected
        if self.network and self.is_online_game:
            self.network.disconnect()
            self.network = None
            self.is_online_game = False
        
        return True

    def handle_connect_screen_click(self, pos):
        """Handle clicks on input fields in the connect screen"""
        form_x = SCREEN_WIDTH // 2 - 200
        form_y = 150
        
        # Check if an input field was clicked
        if form_x + 150 <= pos[0] <= form_x + 350:
            # IP field
            if form_y + 25 <= pos[1] <= form_y + 55:
                self.active_input_field = "ip"
                return True
            # Port field
            elif form_y + 75 <= pos[1] <= form_y + 105:
                self.active_input_field = "port"
                return True
            # Name field
            elif form_y + 125 <= pos[1] <= form_y + 155:
                self.active_input_field = "name"
                return True
        
        # If clicked elsewhere, deactivate text input
        self.active_input_field = None
        return False

    def handle_connect_screen_event(self, event):
        """Handle keyboard input for text fields in connection screen"""
        if event.type == pygame.KEYDOWN:
            # Handle backspace
            if event.key == pygame.K_BACKSPACE:
                if self.active_input_field == "ip" and len(self.server_ip_input) > 0:
                    self.server_ip_input = self.server_ip_input[:-1]
                elif self.active_input_field == "port" and len(self.server_port_input) > 0:
                    self.server_port_input = self.server_port_input[:-1]
                elif self.active_input_field == "name" and len(self.player_name_input) > 0:
                    self.player_name_input = self.player_name_input[:-1]
            
            # Handle enter key to confirm
            elif event.key == pygame.K_RETURN:
                self.connect_to_server()
            
            # Handle tab key to switch fields
            elif event.key == pygame.K_TAB:
                if self.active_input_field == "ip":
                    self.active_input_field = "port"
                elif self.active_input_field == "port":
                    self.active_input_field = "name"
                elif self.active_input_field == "name":
                    self.active_input_field = "ip"
                else:
                    self.active_input_field = "ip"
            
            # Handle text input
            elif event.unicode.isprintable():
                if self.active_input_field == "ip":
                    if event.unicode in "0123456789.":
                        self.server_ip_input += event.unicode
                elif self.active_input_field == "port":
                    if event.unicode in "0123456789":
                        self.server_port_input += event.unicode
                elif self.active_input_field == "name":
                    if len(self.player_name_input) < 15:  # Limit name length
                        self.player_name_input += event.unicode

    def run(self):
        while True:
            self.handle_events()
            self.update()
            
            # Drawing
            self.screen.fill(LIGHT_BLUE)
            
            if self.state == MENU:
                self.draw_menu()
            elif self.state == SETUP:
                self.draw_setup()
            elif self.state == GAMEPLAY:
                self.draw_gameplay()
            elif self.state == GAME_OVER:
                self.draw_game_over()
            elif self.state == ONLINE_SETUP:
                self.draw_connect_screen()
            elif self.state == ONLINE_WAITING:
                self.draw_waiting_screen()
            
            # Draw message if active
            if self.message and self.message_timer > 0:
                msg_text = self.font.render(self.message, True, BLACK)
                msg_bg = pygame.Rect(SCREEN_WIDTH // 2 - msg_text.get_width() // 2 - 10, 650,
                                 msg_text.get_width() + 20, 30)
                pygame.draw.rect(self.screen, (255, 255, 200), msg_bg, 0, border_radius=5)
                pygame.draw.rect(self.screen, BLACK, msg_bg, 1, border_radius=5)
                self.screen.blit(msg_text, (SCREEN_WIDTH // 2 - msg_text.get_width() // 2, 655))
            
            pygame.display.flip()
            self.clock.tick(60)

if __name__ == "__main__":
    game = Game()
    game.run()
